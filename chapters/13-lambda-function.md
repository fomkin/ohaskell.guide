# Лямбда-функция

Пришло время познакомиться с важной концепцией &mdash; лямбда-функцией. Именно с неё всё и началось. Приготовьтесь: в этой главе нас ждут новые открытия.

## Истоки

В далёких 1930-х молодой американский математик [Алонзо Чёрч](https://ru.wikipedia.org/wiki/%D0%A7%D1%91%D1%80%D1%87,_%D0%90%D0%BB%D0%BE%D0%BD%D0%B7%D0%BE) задался вопросом о том, что значит &laquo;вычислить&raquo; что-то. Плодом его размышлений явилась система для формализации понятия &laquo;вычисление&raquo;, и назвал он её &laquo;лямбда-исчислением&raquo; (англ. lambda calculus, по имени греческой буквы `λ`). В основе этой системы лежит лямбда-функция, которую можно считать &laquo;матерью функционального программирования&raquo; в целом и Haskell в частности. Далее буду называть её ЛФ.

В отношении ЛФ можно смело сказать: &laquo;Всё гениальное просто&raquo;. Идея ЛФ столь полезна именно потому, что она предельно проста. ЛФ &mdash; это анонимная функция. Вот как она выглядит в Haskell:

```haskell
\x -> x * x
```

Обратный слэш в начале &mdash; признак ЛФ. Сравните с математической формой записи:

```haskell
λx . x * x
```

Похоже, не правда ли? Воспринимайте обратный слэш в определении ЛФ как спинку буквы `λ`.

ЛФ представляет собой простейший вид функции, эдакая функция, раздетая догола. У неё забрали не только объявление, но и имя, оставив лишь необходимый минимум в виде имён аргументов и внутреннего выражения. Алонзо Чёрч понял: чтобы применить функцию, вовсе необязательно её именовать. И если у обычной функции сначала идёт объявление/определение, а затем (где-то) применение с использованием имени, то у ЛФ всё куда проще: мы её определяем и тут же применяем, на месте. Вот так:

```haskell
(\x -> x * x) 5
```

Помните функцию `square`? Вот это её лямбда-аналог:

```haskell
(\x -> x * x)     5

лямбда-выражение  аргумент
```

Лямбда-выражение порождает временную функцию, которую мы сразу же применяем к аргументу `5`. ЛФ с одним аргументом ещё называют &laquo;ЛФ от одного аргумента&raquo; или &laquo;ЛФ одного аргумента&raquo;.

## Строение

Строение предельно простое:

```haskell
\        x          ->  x * x
признак  имя            выражение
ЛФ       аргумента
```

Соответственно, если ЛФ применяется к двум аргументам &mdash; пишем так:

```haskell
\        x          y          ->  x * y
признак  имя 1      имя 2          выражение
ЛФ       аргумента  аргумента
```

И когда мы применяем такую функцию:

```haskell
(\x y -> x * y) 10 4
```

то просто подставляем `10` на место `x`, а `4` &mdash; на место `y`, и получаем выражение `10 * 4`:

```haskell
(\x y -> x * y) 10 4 = 10 * 4 = 40
```

В общем, всё как с обычной функцией, даже проще.

Мы можем ввести промежуточное значение для ЛФ:

```haskell
main :: IO ()
main = print (mul 10 4)
  where mul = \x y -> x * y
```

Здесь выражение `mul` объявляется равным ЛФ, и теперь мы можем применять `mul` так же, как если бы это было само лямбда-выражение:

```haskell
mul 10 4 = (\x y -> x * y) 10 4 = 10 * 4
```

И здесь мы приблизились к одному важному открытию.

## Тип функции

Мы знаем, что у всех данных в Haskell-программе обязательно есть какой-то тип, проверяемый на этапе компиляции. Вопрос: какой тип у выражения `mul` из предыдущего примера?

```haskell
  where mul = \x y -> x * y  -- Какой тип?
```

Ответ прост: тип `mul` такой же, как и у этой ЛФ. Из этого мы делаем важный вывод: ЛФ имеет тип, как и обычные данные. Но если ЛФ является функцией (просто предельно лаконичной) &mdash; значит и у обыкновенной функции тоже есть тип!

В императивных языках между функциями и данными проведена чёткая граница: вот это функции, а вон то &mdash; данные. Однако в Haskell между данными и функциями разницы нет, ведь и то и другое покоится на одной и той же Черепахе. Вот тип функции `mul`:

```haskell
mul :: a -> a -> a
```

Погодите, скажете вы, но ведь это же объявление функции! Совершенно верно: объявление функции &mdash; это и есть указание её типа. Помните, когда мы впервые познакомились с функцией, я уточнил, что её объявление разделено двойным двоеточием? Так вот это двойное двоеточие и представляет собой указание типа:

```haskell
mul  ::     a -> a -> a

вот  имеет  |   вот   |
это  тип    |_ такой _|
```

Точно так же мы можем указать тип любых других данных:

```haskell
let coeff = 12 :: Double
```

Хотя мы знаем, что в Haskell типы выводятся автоматически, иногда мы хотим взять эту заботу на себя. В данном случае мы явно говорим: &laquo;Пусть выражение `coeff` будет равно `12`, но тип его пусть будет `Double`, а не `Int`&raquo;. Так же и с функцией: когда мы объявляем её &mdash; мы тем самым указываем её тип.

Но вы спросите, можем ли мы не указывать тип функции явно? Можем:

```haskell
square x = x * x
```

Это наша старая знакомая, функция `square`. Когда она будет применена к значению типа `Int`, тип аргумента будет выведен автоматически как `Int`.

И раз функция характеризуется типом так же, как и прочие данные, мы делаем ещё одно важное открытие: функциями можно оперировать как данными. Например, можно создать список функций:

```haskell
main :: IO ()
main = putStrLn ((head functions) "Hi")
  where
    functions = [ \x -> x ++ " val1"
                , \x -> x ++ " val2"
                ]
```

Выражение `functions` &mdash; это список из двух функций. Два лямбда-выражения порождают эти две функции, но до момента применения они ничего не делают, они безжизненны и бесполезны. Но когда мы применяем функцию `head` к этому списку, мы получаем первый элемент списка, то есть первую функцию. И получив, тут же применяем эту функцию к строке `"Hi"`:

```haskell
putStrLn ((head functions)  "Hi")

          |    первая    |  её
          |    функция   |  аргумент
          |__ из списка _|
```

Это равносильно коду:

```haskell
putStrLn ((\x -> x ++ " val1") "Hi")
```

При запуске программы мы получим:

```bash
Hi val1
```

Кстати, а каков тип списка `functions`? Его тип таков: `[String -> String]`. То есть список функций с одним аргументом типа `String`, возвращающих значение типа `String`.

## Локальные функции

Раз уж между ЛФ и простыми функциями фактически нет различий, а функции есть частный случай данных, мы можем создавать функции локально для других функций:

```haskell
-- Здесь определены функции
-- isInfixOf и isSuffixOf.
import Data.List

validComEmail :: String -> Bool
validComEmail email =
    containsAtSign email && endsWithCom email
  where
    containsAtSign e = "@" `isInfixOf` e
    endsWithCom e = ".com" `isSuffixOf` e

main :: IO ()
main = putStrLn (if validComEmail my
                   then "It's ok!"
                   else "Non-com email!")
  where
    my = "haskeller@gmail.com"
```

Несколько наивная функция `validComEmail` проверяет `.com`-адрес. Её выражение образовано оператором `&&` и двумя выражениями типа `Bool`. Вот как образованы эти выражения:

```haskell
containsAtSign e = "@" `isInfixOf` e
endsWithCom e = ".com" `isSuffixOf` e
```

Это &mdash; две функции, которые мы определили прямо в `where`-секции, поэтому они существуют только для основного выражения функции `validComEmail`. С простыми функциями так поступают очень часто: где она нужна, там её и определяют. Мы могли бы написать и более явно:

```haskell
validComEmail :: String -> Bool
validComEmail email =
    containsAtSign email && endsWithCom email
  where
    -- Объявляем локальную функцию явно.
    containsAtSign :: String -> Bool
    containsAtSign e = "@" `isInfixOf` e

    -- И эту тоже.
    endsWithCom :: String -> Bool
    endsWithCom e = ".com" `isSuffixOf` e
```

Впрочем, указывать тип столь простых функций, как правило, необязательно.

Вот как этот код выглядит с ЛФ:

```haskell
validComEmail :: String -> Bool
validComEmail email =
    containsAtSign email && endsWithCom email
  where
    containsAtSign = \e -> "@" `isInfixOf` e
    endsWithCom = \e -> ".com" `isSuffixOf` e
```

Теперь выражения `containsAtSign` и `endsWithCom` приравнены к ЛФ от одного аргумента. В этом случае мы конечно же не указываем тип этих выражений. Впрочем, если очень хочется, можно и указать, например:

```haskell
containsAtSign = (\e -> "@" `isInfixOf` e) :: String -> Bool

                 выражение, порождающее       тип этой функции
                 функцию
```

Лямбда-выражение взято в скобки, чтобы указание типа относилось к функции в целом, а не только к аргументу `e`:

```haskell
containsAtSign = \e -> "@" `isInfixOf` e :: String -> Bool

                                            тип аргумента e,
                                            а вовсе не всей
                                            функции!
```

Для типа функции тоже можно ввести псевдоним:

```haskell
-- Псевдоним для типа функции.
type Func = String -> Bool

validComEmail :: String -> Bool
validComEmail email =
    containsAtSign email && endsWithCom email
  where
    containsAtSign = (\e -> "@" `isInfixOf` e) :: Func
    endsWithCom = (\e -> ".com" `isSuffixOf` e) :: Func
```

Впрочем, на практике указание типа ЛФ встречается крайне редко, ибо незачем.

Теперь, познакомившись с ЛФ, мы будем использовать их периодически.

И напоследок, вопрос. Помните тип функции `mul`?

```haskell
mul :: a -> a -> a
```

Что это за буква `a`? Во-первых, мы не встречали такой тип ранее, а во-вторых, разве имя типа в Haskell не обязано начинаться с большой буквы? Обязано. А всё дело в том, что буква `a` в данном случае &mdash; это не совсем имя типа. А вот что это такое, мы узнаем в одной из ближайших глав.

## Для любопытных

А почему, собственно, лямбда? Почему Чёрч выбрал именно эту греческую букву? По одной из версий, произошло это чисто случайно.

Шли 30-е годы прошлого века, компьютеров не было, и все научные работы набирались на печатных машинках. В первоначальном варианте, дабы выделять имя аргумента ЛФ, Чёрч ставил над именем аргументом символ, похожий на `^`. Но когда он сдавал работу наборщику, то вспомнил, что печатная машинка не сможет воспроизвести такой символ над буквой. Тогда он вынес эту &laquo;крышу&raquo; перед именем аргумента, и получилось что-то наподобие:

```haskell
^x . x * 10
```

А наборщик, увидев такой символ, использовал заглавную греческую букву `Λ`:

```haskell
Λx . x * 10
```

Вот так и получилось, лямбда-исчисление.

